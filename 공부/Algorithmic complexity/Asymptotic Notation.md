컴퓨터 사이언스에서 알고리즘을 비교하고 측정하기 위해서 프로그램의 Asymptotic complexity(점근 복잡도?)를 표현하고 이를 'Big O'(Big Ohnotation)으로 표현하는 것을 고안했다.

배열의 길이를 세는 프로그램이 있을 때, `[1,2,3]`은 3번 센다. 그렇다면 이를 어떻게 표현해야하는가?
3만큼의 속도를 가지는 프로그램이라고 표현해야할까? 그렇다면 배열의 길이가 `[1,2,3,4,5]`가 된다면 5만큼의 속도를 가진다고 표현해야하는가?
아니다, 상식적으로 생각해도 프로그램의 효율성과 속도를 입력하는 데이터의 크기에 의존하도록 비교하는 것은 말이 안된다. 그래서 Big O로 표현하는 것이다. 이런 프로그램은 입력한 데이터의 갯수(n)만큼 실행된다. 이를 O(n)으로 표현한다.

그렇다면 긴 길이의 문자열을 저장하기 위한 프로그램이 있다고 하자. 이 문자열을 하나씩 셀 수가 없어 특정 길이 이하의 문자열만 저장하려고 하여 변수 len에 1000이라는 수를 저장했다. 이제 len보다 적은 길이의 문자열만 저장한다고 했을 때, 복잡도는 얼마가 되는가? O(1)이다. 각 문자열의 len을 확인하고 저장할지 안 할지 결정한다. 결정하는 시행횟수 1번이 이 프로그램의 전부이다. O(1)이라고 하거나, constant time(불변시간?)이라고 한다.

O(n^2)은 O(n)보다 느릴 것이다. 시행횟수가 훨씬 많기 때문에, 하지만 이것은 O(n)^2가 항상 느리다는 것을 시사하는 것은 아니다. 지수함수니까, 그저 입력값만 적다면 O(n)^2도 빠르다. 하지만 입력값이 증가함에 따라 그 수는 기하급수적으로 늘어날것이다.

또 다른 복잡도는 O(log n)이다. 예를 들어 `[1,2,3,4,5,6,7]`의 배열에서 3을 찾는 프로그램이다. 가장 먼저 중간을 확인하여 같은지 큰지 확인한다. 같으면 끝, 크다면 오른쪽, 작다면 왼쪽을 다시 확인한다. 이번에는 작기 때문에 `[1,2,3]`의 중간을 확인한다. 2와 같으면 끝, 크다면 오른쪽, 작다면 왼쪽을 다시 확인한다. 크기 때문에 `[3]`을 확인한다. 같으므로 종료된다. 이렇게 길이가 계속 절반씩 줄어드는 log n의 값을 가지는 알고리즘을 O(log n)으로 표현한다.

가장 좋은 경우와 나쁜 경우가 n으로 같은 경우에는 세타(n)으로 표현한다.