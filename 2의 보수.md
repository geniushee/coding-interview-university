2의 보수란 2^N에 대한 해당 숫자의 보수이다. 어떤 수와 그 보수를 합하면 2^N이 되는 것을 2의 보수라 한다.  2^3 = 1000 = 011 + 101 가 된다. 011의 2의 보수는 101이다.

2의 보수는 덧셈 , 뺄셈, 곱셈 의 기본 산술 연산이 부호 없는 이진수의 연산과 동일하다는 장점이 있습니다(입력이 출력과 같은 비트 수로 표현되고 해당 비트를 넘어서는 오버플로는 결과에서 삭제되는 한). 이 속성 덕분에 특히 고정밀 산술의 경우 시스템을 구현하기가 더 간단합니다. 또한 1의 보수 시스템과 달리 2의 보수는 음의 0에 대한 표현이 없으므로 관련된 어려움이 없습니다.

## 변경 방법
0000 0101
**가장 중요한 비트(이 경우 가장 왼쪽 비트)는 0이므로 패턴은 음이 아닌 값을 나타냅니다.** **2의 보수 표기법으로 -5로 변환하려면 먼저 모든 비트를 반전**합니다. 즉, 0은 1이 되고 1은 0이 됩니다.

1111 1010
이 지점에서 표현은 10진수 값 -5의 1의 보수입니다. **2의 보수를 얻으려면 결과에 1을 더하여 다음을 얻습니다.**

1111 1011
**결과는 2의 보수 형태로 10진수 값 -5를 나타내는 부호 있는 2진수입니다.** 가장 중요한 비트는 1이며, 이는 표현된 값이 음수임을 나타냅니다.

음수의 2의 보수는 가장 음수인 특별한 경우를 제외하고는 해당 양수 값입니다. 예를 들어, −5(위)의 비트를 반전하면 다음과 같습니다.

0000 0100

그리고 1을 더하면 최종 값이 나옵니다.

0000 0101

가장 표현 가능한 음수의 2의 보수(예: 가장 중요한 비트로 1을 사용하고 다른 모든 비트는 0)는 그 자체입니다. 따라서 2의 보수가 부정을 제공하지 않는 '추가' 음수가 있습니다.

## 최고 음수
8비트 시스템에서 -128 의 2의 보수는 -128 입니다. -128을 부정하는 예상 결과는 +128 이지만 8비트 2의 보수 시스템에서 +128을 표현할 수 없으므로 실제로 부정을 표현하는 것은 불가능합니다. 2의 보수가 같은 숫자인 것은 최상위 비트로 캐리가 들어갔지만 나오지 않았기 때문에 오버플로 조건으로 감지됩니다.
가장 큰 음수가 존재하면 예상치 못한 프로그래밍 버그가 발생할 수 있으며, 결과에 예상치 못한 부호가 생기거나 예상치 못한 오버플로 예외가 발생하거나 완전히 이상한 동작이 발생할 수 있습니다.


## 계산
### 덧셈
2의 보수 숫자를 더하는 데는 피연산자의 부호가 반대일지라도 특별한 처리가 필요하지 않습니다. 결과의 부호는 자동으로 결정됩니다. 예를 들어, 15와 -5를 더하면 다음과 같습니다.

   0000 1111 (15)
 + 1111 1011 (−5)
 ===========
   0000 1010 (10)

또는 5 − 15 = 5 + (−15)의 계산:

   0000 0101 ( 5)
 + 1111 0001 (-15)
 ===========
   1111 0110 (-10)


왼쪽 두 캐리 비트(이 예에서 맨 위 행의 가장 왼쪽에 있는 비트)가 모두 1이거나 모두 0이면 결과가 유효합니다. 왼쪽 두 캐리 비트가 "1 0" 또는 "0 1"이면 부호 오버플로가 발생한 것입니다. 편리하게도, 이 두 비트에 대한 XOR 연산을 통해 오버플로 조건이 있는지 빠르게 확인할 수 있습니다. 예를 들어, 7과 3의 부호 있는 4비트 추가를 고려해 보겠습니다.

  0111(캐리)
   0111 (7)
 + 0011 (3)
 ======
   1010 (−6)이 잘못되었습니다!

이 경우, 가장 왼쪽의 두 개(MSB) 캐리 비트는 "01"이며, 이는 2의 보수 덧셈 오버플로가 발생했음을 의미합니다. 즉, 1010 2 = 10 10 은 허용 범위인 -8~7을 벗어납니다. 부호 없는 정수로 처리하면 결과가 정확할 것입니다.

## 뺄셈
덧셈과 마찬가지로 2의 보수를 사용하는 장점은 피연산자의 부호를 검사하여 덧셈 또는 뺄셈이 필요한지 여부를 판단할 필요가 없다는 것입니다. 예를 들어, 15에서 -5를 빼는 것은 실제로 5를 15에 더하는 것이지만, 이것은 2의 보수 표현에 의해 가려집니다.

  11110 000 (대출)
   0000 1111 (15)
 − 1111 1011 (−5)
 ===========
   0001 0100 (20)
오버플로는 덧셈과 같은 방식으로 감지되는데, 즉 빌림의 가장 왼쪽(가장 중요한) 두 비트를 검사하여 감지합니다. 두 비트가 다르면 오버플로가 발생한 것입니다.


