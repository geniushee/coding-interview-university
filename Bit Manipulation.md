# Bit Manipulation
기본적인 명령어

| and | &   | not         | ~   |
| --- | --- | ----------- | --- |
| or  | \|  | left shift  | <<  |
| xor | ^   | right shift | >>  |

```
AND - Only true if both input bits are true.
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1

10010110 & 00110010 => 00010010


OR
0 | 0 = 0
1 | 0 = 1
0 | 1 = 1
1 | 1 = 1

10010110 & 00110010 => 1011110


XOR
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
1 ^ 1 = 0

10010110 ^ 00110010 => 10100100

NOT
~0 = 1
~1 = 0

~10010110 => 01101001


Left Shift
00010110 << 00000010 => 01011000

Right Shift
00010110 >> 00000010 => 00000101

```

Left Shift는 1번 옮길때마다 2씩 곱하는 효과가 있다. 또한 가장 오른쪽에는 0이 추가된다. 하지만 데이터 크기를 넘어서 1이 왼쪽으로 이동된다면 버려지게 된다.

Right Shift는 1번 옮길때마다 2로 나누는 효과가 있다. 또한 가장 왼쪽에는 0이 추가된다. 가장 오른쪽의 0 또는 1은 버려지게 된다.

## Bit Mask 활용방법
### 1. 특정 비트 설정 (set  a bit)
어떤 비트를 1로 만들고 싶다면 OR 연산자(|)를 사용한다.
```python
def set_bit(x, position):
	mask = 1 << position
	return x | mask

# x = 00000110, position = 00000101, mask = 00100000, result = 00100110
```

### 2. 특정 비트 지우기(Clear a bit)
어떤 비트를 0으로 만들고 싶다면 AND연산자(&)와 NOT 연산자 (~)를 사용한다.
```python
def clear_bit(x, position):
	mask = 1 << position
	return x & ~mask

# x = 00000110, position = 00000010, mask = 00000100, result = 00000010
```


### 3. 특정 비트 토글하기(Flip a bit)
```python
def flip_bit(x, position):
	mask = 1 << position
	return x ^ mask

# x = 01100110, position = 00000010, mask = 00000100, result = 01100010
```

---
### IS BIT SET
해당 위치의 BIT가 1인지 0인지 확인한다. 위치를 2x0으로 옮긴후 1과 AND 연산자(&)를 사용하여 사용한다.
```python
def is_bit_set(x, position):
	shifted = x >> position
	return shifted & 1

# x = 01100110, position = 00000101, shifted = 0000011 result = true
```


### MODIFY BIT
State의 값에 따라서 변경 및 삭제가 이루어 집니다.
```python
def modify_bit(x, position, state):
	mask = 1 << position
	return (x & ~mask) | (~state & mask)
# state가 1이면 set하고 0이면 clear한다.

# x = 00000110, position = 00000101, state = 00000001, mask = 00100000
# ~mask = 11011111, ~state = 11111111, result = 00100110

# x = 00000110, position = 00000010, state = 00000000, mask = 00000010
# ~mask = 11111101, ~state = 00000000, result = 00000010
```

`x & ~mask`는 위에서 봤던 특정 비트 지우기와 동일하게 동작합니다. 그리고 `state`가 1일 때 `~state & mask`는 `mask`와 동일합니다. 따라서 `state = 1`이면 1로 변경이 되고 `state = 0`이면 해당 포지션의 비트가 삭제됩니다.
이때, 1의 NOT은 -1로 BIT는 `1`로 꽉 채워지게 되는데 보수의 개념이 사용됩니다. 그리고 0의 NOT은 즉, 음수 0은 존재하지 않기 때문에 함수의 결과로 포지션의 1이 지워지게 됩니다. (일단 0이던 1이던 지우고 state가 1이면 추가, 0이면 그대로 반환)
>보수 더했을 때, 0이 되는 수

---
## BIT TRICKS

1. 짝수 확인 방법
	1. 모든 2진수에서 홀수는 가장 오른쪽이 1이므로 이진수 확인만 하면된다. 모듈로(%) 연산 없이
	2. x & 1 == 0 (짝수)
	3. not(x & 1) (짝수)
2. 2의 거듭제곱인지 확인
	1. x & x-1 == 0
	2. 2의 거듭제곱은 1이 1개만 있고 나머지는 0이다. 이때, 1을 빼면 원래 1이 있던 자리 이하의 모든 자리수가 0에서 1로 변경(채워지고) & 연산자를 사용하면 같은 위치의 1이 없으므로 0을 반환하게 된다.


## EXERCISE
write a function to count the number of bits that are different between tow numbers

http://bits.stephan-brumme.com/
http://h14s.p5r.org/2012/09/0x5f3759df.html/
http://en.wikipedia.org/wiki/Fast_inverse_square_root

---

# Bitwise Operators in C Programming

~ NOT 연산자를 One's Complement라고 표현 즉 합쳤을 때, 1로 가득채울 수 있는 것을 말한다.

---
# BIT Manipulatio(비트 조작 wiki)
**비트 조작**은 알고리즘적으로 비트 또는 워드(word)보다 작은 데이터 조각을 다루는 것을 의미합니다.
- 저수준 장치 제어
- 오류 검출 및 수정 알고리즘
- 데이터 압축
- 암호화 알고리즘
- 최적화

일부 경우에는 비트 조작을 통해 데이터 구조를 반복할 필요성을 없애거나 줄일 수 있으며, 비트 조작은 병렬로 처리되므로 여러 배의 속도 향상을 가져올 수 있습니다.
대부분의 프로세서에서 비트 연산의 대부분은 단일 사이클로 수행되며, 이는 나눗셈, 곱셈 및 분기보다 상당히 빠릅니다. 현대 프로세서는 일반적으로 일부 산술 및 논리 연산을 수행하지만, 비트 연산은 여전히 효율적인 방법으로 사용됩니다.
이러한 비트 조작은 효율적인 프로그래밍과 성능 최적화를 위해 중요하게 사용됩니다.

---
# BIT OPERATORS

[[2의 보수]]
![[8비트 정수.png]]

## 비트 어드레싱
 "왼쪽" 및 "오른쪽" 방향은 자릿수 표기법에서 숫자를 표준으로 쓰는 방식에서 가져온 것이며 [,](https://en.wikipedia.org/wiki/Place-value_notation "자릿값 표기법") 왼쪽 시프트는 숫자 값을 증가시키고 오른쪽 시프트는 숫자 값을 감소시킵니다. 왼쪽 숫자를 먼저 읽으면 빅 [엔디](https://en.wikipedia.org/wiki/Big-endian "빅 엔디안") 언 방향이 됩니다. 레지스터의 양쪽 끝에서 경계 효과를 무시하면 산술 및 논리 시프트 연산은 동일하게 동작하며, 8비트 위치만큼 시프트하면 다음과 같이 비트 패턴이 1바이트 위치만큼 전송됩니다.

| 리틀 엔디언 순서: | 8개 위치만큼 왼쪽으로 이동하면 바이트 주소가 1만큼 증가합니다. |
| ---------- | ------------------------------------ |
|            | 오른쪽으로 8위치 이동하면 바이트 주소가 1 감소합니다.      |
| 빅 엔디언 순서:  | 8개 위치만큼 왼쪽으로 이동하면 바이트 주소가 1만큼 감소합니다. |
|            | 오른쪽으로 8위치 이동하면 바이트 주소가 1 증가합니다.      |

### 산술 시프트
_산술 시프트_ 에서 양쪽 끝에서 시프트된 비트는 버려집니다. 왼쪽 산술 시프트에서 0은 오른쪽으로 시프트되고, 오른쪽 산술 시프트에서 부호 비트(2의 보수에서 MSB)는 왼쪽으로 시프트되어 피연산자의 부호가 보존됩니다.

이 예제에서는 2의 보수로 해석되는 8비트 레지스터를 사용합니다.
   00010111 (10진수 +23) 왼쪽 SHIFT = 0010111 **0** (10진수 +46)
   10010111 (10진수 -105) 오른쪽 쉬프트 =   **1** 1001011 (10진수 -53)

### 논리적 쉬프트

|   |   |
|---|---|
|[![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Rotate_left_logically.svg/150px-Rotate_left_logically.svg.png)](https://en.wikipedia.org/wiki/File:Rotate_left_logically.svg)<br><br>왼쪽 논리적 이동|[![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/Rotate_right_logically.svg/250px-Rotate_right_logically.svg.png)](https://en.wikipedia.org/wiki/File:Rotate_right_logically.svg)<br><br>오른쪽 논리적 이동|

_논리적 쉬프트_ 에서 , 0은 버려진 비트를 대체하기 위해 쉬프트됩니다. 따라서 논리적 및 산술적 왼쪽 쉬프트는 정확히 동일합니다.

그러나 논리적 오른쪽 시프트는 부호 비트를 복사하는 대신 값 0 비트를 최상위 비트에 삽입하므로 부호 없는 이진수에 이상적인 반면, 산술적 오른쪽 시프트는 부호 있는 2의 보수 이진수에 이상적입니다.


#### 자바
Java 에서 모든 정수 유형은 부호가 있으므로 " `<<`" 및 " `>>`" 연산자는 산술 쉬프트를 수행합니다. Java는 연산자 " >>>"를 추가하여 논리적 오른쪽 쉬프트를 수행하지만, 논리적 및 산술 왼쪽 쉬프트 연산은 부호가 있는 정수에 대해 동일하므로 Java에는 "<<<" 연산자가 없습니다.

Java 이동 연산자에 대한 자세한 내용: 
- `<<`(왼쪽 이동), `>>`(부호 있는 오른쪽 이동), (부호 없는 오른쪽 이동) 연산자 _를 이동 연산자_`>>>` 라고 합니다 .
- 이동 표현식의 유형은 왼쪽 피연산자의 승격된 유형입니다. 예를 들어, 는 . `aByte >>> 2`와 동등합니다 .`((int) aByte) >>> 2`
- 왼쪽 피연산자의 승격된 유형이 int인 경우 오른쪽 피연산자의 가장 낮은 순서의 5개 비트만 이동 거리로 사용됩니다. 이는 오른쪽 피연산자가 마스크 값 0x1f(0b11111)를 갖는 비트 논리 AND 연산자 &에 적용된 것과 같습니다. 따라서 실제로 사용되는 이동 거리는 항상 0~31 범위에 있습니다.
- 왼쪽 피연산자의 승격된 유형이 긴 경우 오른쪽 피연산자의 가장 낮은 순서의 6개 비트만 이동 거리로 사용됩니다. 이는 오른쪽 피연산자가 마스크 값 0x3f(0b111111)를 갖는 비트 논리 AND 연산자 &에 적용된 것과 같습니다. 따라서 실제로 사용되는 이동 거리는 항상 0~63 범위에 있습니다.
- `n >>> s` 값은 0 확장을 사용하여 오른쪽으로 이동한 n비트위치 입니다 .
- 비트 및 시프트 연산에서 `byte`유형은 암묵적으로 `int`으로 변환됩니다. 바이트 값이 음수이고 가장 높은 비트가 1이면 1을 사용하여 int의 추가 바이트를 채웁니다. 따라서 `byte b1 = -5; int i = b1 | 0x0200;``i == -5`이 됩니다 .